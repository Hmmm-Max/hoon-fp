::
::::  /hook/gate/fp/cat
  ::
/?  314
::
::::
!:  =<
=+  f==>(fl .(p 24, v -149, w 253, r %n))
|=  [* [[a=[? @s @u] b=[? @s @u] ~] ~]]
:-  %noun  (lte:f [%f a] [%f b])
::|=  [* [[a=[? @s @u] ~] ~]]
:::-  %noun  (uni:fl [%f a])
::
|%
++  fn  ::  float, infinity, or NaN
        ::  s=sign, e=exponent, a=arithmetic form
        ::  (-1)^s * a * 2^e
        ::  c=& : signalling NaN, c=| : quiet NaN
        $%  [%f s=? e=@s a=@u]
            [%i s=?]
            [%n c=?]
        ==
::
++  fl
  |_  [p=@u v=@s w=@u r=?(%n %u %d %z)]
  ::  p=precision: number of bits in arithmetic form (NOT HIDDEN BIT!!)
  ::  v=minimum value of e
  ::  w=width: max-min value of e
  ::  r=rounding mode: round to nearest, round up, round down, round to 0
  ::  binary32: [24 -149 253 r] (-149 = -126 - 24 + 1)
  ++  con
    |%
    ++  emn  (sum:si v (sun:si (sub p 1)))
    ++  emx  (sum:si emn (sun:si w))
    ++  uex  (sum:si v (sun:si w))
    ++  spd  [%f v 1]                                   ::  smallest pos. "denormal" number
    ++  spn  [%f emn 1]                                 ::  smallest pos. "normal" number
    ++  lfn  [%f uex (fil 0 p 1)]                       ::  largest finite number
    --
  ::
  ::  if a.a!=0, 2^mag(a) <= |a| < 2^(mag(a) + 1)
  ::  helps optimize comparison tests
  ::  so we don't do really big shifts for no reason
  ++  mag  |=  [a=fn]  ^-  @s
           ?>  ?=([%f *] a)
           (sum:si (sun:si (dec (met 0 a.a))) e.a)
  ::
  ++  equ  |=  [a=fn b=fn]  ^-  (unit ,?)
           ?:  |(?=([%n *] a) ?=([%n *] b))  ~  :-  ~
           ?:  =(a b)  &
           ?:  |(?=([%i *] a) ?=([%i *] b))  |
           ?:  |(=(a.a 0) =(a.b 0))
             ?:  &(=(a.a 0) =(a.b 0))  &  |
           ?:  |(=(e.a e.b) !=(s.a s.b) !=((mag a) (mag b)))  |
           ?:  =((cmp:si e.a e.b) -1)                   ::  e.a < e.b
             =((lsh 0 (abs:si (dif:si e.a e.b)) a.b) a.a)
           =((lsh 0 (abs:si (dif:si e.a e.b)) a.a) a.b)
  ::
  ++  lth  |=  [a=fn b=fn]  ^-  (unit ,?)
           ?:  |(?=([%n *] a) ?=([%n *] b))  ~  :-  ~
           ?:  =(a b)  |
           ?:  ?=([%i *] a)  !s.a  ?:  ?=([%i *] b)  s.b
           ?:  |(=(a.a 0) =(a.b 0))
             ?:  &(=(a.a 0) =(a.b 0))  |
             ?:  =(a.a 0)  s.b  !s.a
           ?:  !=(s.a s.b)  s.b
           |-  ?:  =(s.a |)  $(a [%f & e.b a.b], b [%f & e.a a.a])
           ?:  =(e.a e.b)  (^lth a.a a.b)
           =+  c=(cmp:si (mag a) (mag b))
           ?:  =(c -1)  &  ?:  =(c --1)  |
           ?:  =((cmp:si e.a e.b) -1)
             (^lth (rsh 0 (abs:si (dif:si e.a e.b)) a.a) a.b)
           (^lth (lsh 0 (abs:si (dif:si e.a e.b)) a.a) a.b)
  ::
  ++  lte  |=  [a=fn b=fn]  ^-  (unit ,?)
           ?:  |(?=([%n *] a) ?=([%n *] b))  ~  :-  ~
           ?:  =(a b)  &
           ?:  ?=([%i *] a)  !s.a  ?:  ?=([%i *] b)  s.b
           ?:  |(=(a.a 0) =(a.b 0))
             ?:  &(=(a.a 0) =(a.b 0))  &
             ?:  =(a.a 0)  s.b  !s.a
           ?:  !=(s.a s.b)  s.b
           |-  ?:  =(s.a |)  $(a [%f & e.b a.b], b [%f & e.a a.a])
           ?:  =(e.a e.b)  (^lth a.a a.b)
           =+  c=(cmp:si (mag a) (mag b))
           ?:  =(c -1)  &  ?:  =(c --1)  |
           ?:  =((cmp:si e.a e.b) -1)
             (^lte a.a (lsh 0 (abs:si (dif:si e.a e.b)) a.b))
           (^lte (lsh 0 (abs:si (dif:si e.a e.b)) a.a) a.b)
  ::
  ++  gth  |=  [a=fn b=fn]  ^-  (unit ,?)  (lth b a)
  ::
  ++  gte  |=  [a=fn b=fn]  ^-  (unit ,?)  (lte b a)
  ::
  ::  =((uni a) (uni b)) if and only if (equ a b), with the
  ::  exception of positive/negative 0, which are distinct in
  ::  ++uni but considered equal in comparisons
  ++  uni  |=  [a=fn]  ^-  fn
           ?.  ?=([%f *] a)  a
           ?:  =(a.a 0)  [%f s.a --0 0]
           |-  ^-  fn
           ?:  =((dis a.a 1) 1)  a
           $(a.a (rsh 0 1 a.a), e.a (sum:si e.a --1))
  ::
  ++  rnd  |=  [a=fn]
           !!
  --
--
