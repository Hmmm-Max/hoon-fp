::
::::  /hook/gate/fp/cat
  ::
/?  314
::
::::
!:  =<
=+  f==>(fl .(p 24, v -149, w 253, r %n))
::|=  [* [[a=[? @s @u] b=[? @s @u] ~] ~]]
:::-  %noun  (lte:f [%f a] [%f b])
|=  [* [[a=[? @s @u] ~] ~]]
:-  %noun  (rou:f [%f a])
::
|%
++  fn  ::  float, infinity, or NaN
        ::  s=sign, e=exponent, a=arithmetic form
        ::  (-1)^s * a * 2^e
        ::  c=& : signalling NaN, c=| : quiet NaN
        $%  [%f s=? e=@s a=@u]
            [%i s=?]
            [%n c=?]
        ==
::
++  fl
  |_  [p=@u v=@s w=@u r=?(%n %u %d %z)]
  ::  p=precision: number of bits in arithmetic form (NOT HIDDEN BIT!!)
  ::  v=minimum value of e
  ::  w=width: max - min value of e
  ::  r=rounding mode: round to nearest, round up, round down, round to 0
  ::  binary32: [24 -149 253 r] (-149 = -126 - 24 + 1)
  ::
  ++  m                                                 ::  internal functions, constants
    |%
    ::  do not put 0s into these
    ++  equ  |=  [a=[e=@s a=@u] b=[e=@s a=@u]]
             ?.  =((log a) (log b))  |
             ?:  =((cmp:si e.a e.b) -1)
               =((lsh 0 (abs:si (dif:si e.a e.b)) a.b) a.a)
             =((lsh 0 (abs:si (dif:si e.a e.b)) a.a) a.b)
    ::
    ++  lth  |=  [a=[e=@s a=@u] b=[e=@s a=@u]]
             ?:  =(e.a e.b)  (^^lth a.a a.b)
             =+  c=(cmp:si (log a) (log b))
             ?:  =(c -1)  &  ?:  =(c --1)  |
             ?:  =((cmp:si e.a e.b) -1)
               (^^lth (rsh 0 (abs:si (dif:si e.a e.b)) a.a) a.b)
             (^^lth (lsh 0 (abs:si (dif:si e.a e.b)) a.a) a.b)
    ::
    ++  lte  |=  [a=[e=@s a=@u] b=[e=@s a=@u]]
             ?:  =(e.a e.b)  (^^lte a.a a.b)
             =+  c=(cmp:si (log a) (log b))
             ?:  =(c -1)  &  ?:  =(c --1)  |
             ?:  =((cmp:si e.a e.b) -1)
               (^^lte a.a (lsh 0 (abs:si (dif:si e.a e.b)) a.b))
             (^^lte (lsh 0 (abs:si (dif:si e.a e.b)) a.a) a.b)
    ::
    ++  log  |=  [a=[e=@s a=@u]]
             (sum:si (sun:si (dec (met 0 a.a))) e.a)
    ::
    ++  uni  |=  [a=[e=@s a=@u]]
             ?<  =(a.a 0)
             |-  ?:  =((end 0 1 a.a) 1)  a
             $(a.a (rsh 0 1 a.a), e.a (sum:si e.a --1))
    ::
    ::  largest float smaller than or equal to a
    ++  flr  |=  [a=[e=@s a=@u]]  ^-  fn
             =+  m=(met 0 a.a)
             =+  ^=  b  ?.  (^gth m p)  a               ::  reduce precision
               =+  (^sub m p)  a(e (sum:si e.a (sun:si -)), a (rsh 0 - a.a))
             =+  ^=  c  ?.  =((cmp:si e.b v) -1)  b     ::  enforce min. exp
               =+  (dif:si v e.b)  b(e (sum:si e.b -), a (rsh 0 (abs:si -) a.b))
             ?:  =(a.c 0)  [%f & --0 0]
             =+  ^=  d  ?.  =((cmp:si e.c uex) --1)  c  ::  enforce max. exp
               c(e uex, a (lsh 0 (abs:si (dif:si e.c uex)) a.c))
             ?:  (^gth (met 0 a.d) p)  [%i &]  [%f & d]
    ::
    ::  smallest float larger than or equal to a
    ++  cei  |=  [a=[e=@s a=@u]]  ^-  fn
             =+  m=(met 0 a.a)  =+  f=(^gth m p)
             =+  q=?:(f (^sub m p) 0)
             =+  ^=  b  ?.  f  a                        ::  reduce precision
               a(e (sum:si e.a (sun:si q)), a (rsh 0 q a.a))
             =+  g==((cmp:si e.b v) -1)
             =+  r=?:(g (dif:si v e.b) --0)
             =+  ^=  c  ?.  g  b                        ::  enforce min. exp
               b(e (sum:si e.b r), a (rsh 0 (abs:si r) a.b))
             ?:  =(a.c 0)  [%f & spd]
             =+  ^=  d  ?.  |(f g)  c                   ::  if flagged, increment?
               ?~  (end 0 (^add q (abs:si r)) a.a)  c   ::  if cutoff was just 0s
               =+  (min (abs:si (dif:si e.c v)) (^sub p (met 0 a.c)))
               (uni c(e (dif:si e.c (sun:si -)), a +((lsh 0 - a.c))))
             =+  ^=  e  ?.  =((cmp:si e.d uex) --1)  d  ::  enforce max. exp
               d(e uex, a (lsh 0 (abs:si (dif:si e.d uex)) a.d))
             ?:  (^gth (met 0 a.e) p)  [%i &]  [%f & e]
    ::
    ::  nearest float to a, round to even
    ++  nea  |=  [a=[e=@s a=@u]]  ^-  fn
             =+  m=(met 0 a.a)  =+  f=(^gth m p)
             =+  q=?:(f (^sub m p) 0)
             =+  ^=  b  ?.  f  a                        ::  reduce precision
               a(e (sum:si e.a (sun:si q)), a (rsh 0 q a.a))
             =+  g==((cmp:si e.b v) -1)
             =+  r=?:(g (dif:si v e.b) --0)
             =+  ^=  c  ?.  g  b                        ::  enforce min. exp
               b(e (sum:si e.b r), a (rsh 0 (abs:si r) a.b))
             =+  w=(^add q (abs:si r))
             =+  [x=(end 0 w a.a) y=?~(w 0 (bex (dec w)))]
             ?:  =(a.c 0)  [%f & ?:((^^lte x y) zer spd)]
             =+  ^=  d                                  ::  expand
               =+  (min (abs:si (dif:si e.c v)) (^sub p (met 0 a.c)))
               c(e (dif:si e.c (sun:si -)), a (lsh 0 - a.c))
             =+  ^=  e  %-  uni  ?.  &(|(f g) !=(x 0))  d
               ?:  =(x y)                               ::  exactly halfway between
                 ?:  =((dis a.d 1) 0)  d  d(a +(a.d))
               ?:  (^^lth x y)  d  d(a +(a.d))
             =+  ^=  f  ?.  =((cmp:si e.e uex) --1)  e  ::  enforce max. exp
               e(e uex, a (lsh 0 (abs:si (dif:si e.e uex)) a.e))
             ?:  (^gth (met 0 a.f) p)  [%i &]  [%f & f]
    ::
    ++  emn  (sum:si v (sun:si (dec p)))
    ++  emx  (sum:si emn (sun:si w))
    ++  uex  (sum:si v (sun:si w))
    ++  spd  [v 1]                                      ::  smallest "denormal"
    ++  spn  [emn 1]                                    ::  smallest "normal"
    ++  lfn  [uex (fil 0 p 1)]                          ::  largest
    ++  zer  [--0 0]                                    ::  zero
    --
  ::
  ++  rou  |=  [a=fn]  ^-  fn
           ?.  ?=([%f *] a)  a
           ?~  a.a  [%f s.a --0 0]
           ?-  r
             %n  ?:(s.a (nea:m +>.a) (fli (nea:m +>.a)))
             %u  ?:(s.a (cei:m +>.a) (fli (flr:m +>.a)))
             %d  ?:(s.a (flr:m +>.a) (fli (cei:m +>.a)))
             %z  ?:(s.a (flr:m +>.a) (fli (flr:m +>.a)))
           ==
  ::
  ++  fli  |=  [a=fn]  ^-  fn
           ?-(-.a %f a(s !s.a), %i a(s !s.a), %n a)
  ::
  ++  add  |=  [a=fn b=fn]  ^-  fn
           !!
  ::
  ++  sub  |=  [a=fn b=fn]  ^-  fn
           !!
  ::
  ++  mul  |=  [a=fn b=fn]  ^-  fn
           !!
  ::
  ++  div  |=  [a=fn b=fn]  ^-  fn
           !!
  ::
  ++  sqt  |=  [a=fn]  ^-  fn
           !!
  ::
  ++  equ  |=  [a=fn b=fn]  ^-  (unit ,?)
           ?:  |(?=([%n *] a) ?=([%n *] b))  ~  :-  ~
           ?:  =(a b)  &
           ?:  |(?=([%i *] a) ?=([%i *] b))  |
           ?:  |(=(a.a 0) =(a.b 0))
             ?:  &(=(a.a 0) =(a.b 0))  &  |
           ?:  |(=(e.a e.b) !=(s.a s.b))  |
           (equ:m +>.a +>.b)
  ::
  ++  lth  |=  [a=fn b=fn]  ^-  (unit ,?)
           ?:  |(?=([%n *] a) ?=([%n *] b))  ~  :-  ~
           ?:  =(a b)  |
           ?:  ?=([%i *] a)  !s.a  ?:  ?=([%i *] b)  s.b
           ?:  |(=(a.a 0) =(a.b 0))
             ?:  &(=(a.a 0) =(a.b 0))  |
             ?:  =(a.a 0)  s.b  !s.a
           ?:  !=(s.a s.b)  s.b
           |-  ?:  =(s.a |)  $(a [%f & e.b a.b], b [%f & e.a a.a])
           (lth:m +>.a +>.b)
  ::
  ++  lte  |=  [a=fn b=fn]  ^-  (unit ,?)
           ?:  |(?=([%n *] a) ?=([%n *] b))  ~  :-  ~
           ?:  =(a b)  &
           ?:  ?=([%i *] a)  !s.a  ?:  ?=([%i *] b)  s.b
           ?:  |(=(a.a 0) =(a.b 0))
             ?:  &(=(a.a 0) =(a.b 0))  &
             ?:  =(a.a 0)  s.b  !s.a
           ?:  !=(s.a s.b)  s.b
           |-  ?:  =(s.a |)  $(a [%f & e.b a.b], b [%f & e.a a.a])
           (lte:m +>.a +>.b)
  ::
  ++  gth  |=  [a=fn b=fn]  ^-  (unit ,?)  (lth b a)
  ::
  ++  gte  |=  [a=fn b=fn]  ^-  (unit ,?)  (lte b a)
  ::
  ::  =((uni a) (uni b)) if and only if (equ a b), with the
  ::  exception of positive/negative 0, which are distinct in
  ::  ++uni but considered equal in comparisons
  ++  uni  |=  [a=fn]  ^-  fn
           ?.  ?=([%f *] a)  a
           ?:  =(a.a 0)  [%f s.a zer:m]
           [%f s.a (uni:m +>.a)]
  --
--
